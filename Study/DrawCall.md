#### 드로우콜

간단히 말해서 GPU는 CPU의 명령에 따라 렌더링 작업을 수행하는데, CPU가 GPU에게 오브젝트를 그리라는 명령을 하는게 드로우콜이다.

메시정보, 알베도, 메탈릭, 라이팅을 어떻게처리할지 쉐이더정보, 알파블렌딩 등등 이러한 정보들을 CPU에서 GPU로 전달되어서 그려지게된다. 이러한 과정들이 화면에 그려져야할 오브젝트들 모두 다 진행하게되면 그제서야 한 프레임이 완성되는것이다.

하드나 SDD에 들어있는 지오메트리 데이터들을 CPU 메모리인 RAM에 로드하고 GPU도 바로 RAM에 접근하는게 아닌 GPU메모리로 로드하여 접근하는 방식이다. 데이터를 전달하고 오는 과정을 매 프레임마다 하기에는 벅차기 때문에 로딩 시점에 한번에 사용할 양만큼 로드를 해놓는다. 텍스쳐나 쉐이더 등 렌더링에 필요한 데이터 모두 GPU 메모리에 있어야 GPU가 사용할 수 있다.

CPU가 GPU에게 명령을 보낸다고 표현하지만 사실 한단계를 더거친다. 명령버퍼에 쌓아놓고 순차적으로 작업할수있도록. API가 호출되면 GPU 드라이버 칩셋에 알맞는 신호로 전달하여 명령을 해석하고 변형하는 과정을 거침. 이 과정을 거치기 때문에 CPU가 GPU에 명령을 보낼때 오버헤드가 발생하게됨. 결국 **드로우콜은 CPU 바운더리의 오버헤드임** 그 말은 드로우콜은 GPU성농보다 CPU성능에 더 의존적이다.

드로우콜로 인한 성능하락을 줄이기 위해서는 드로우콜 횟수를 줄여야한다.



#### 드로우콜 발생조건

1. 메시의 수 => 오브젝트는 하나일지라도 메시가 여러개 존재할 수 있다.
2. 머테리얼의 수
3. 쉐이더에 의한 경우 => 예를 들면 외곽선을 그릴때 2Pass 를 이용해서 드로우콜이 한번더 발생될 수 있음



#### Batch

넓은 의미의 드로우콜이긴하다. 다만 메시의 변경을 포함하지 않는다.



#### SetPass

렌더링패스 횟수를 의미함. 쉐이더의 변경 혹은 쉐이더 파라미터들의 변경시 일어남. SetPass콜이 적으면 그만큼 Batch구성이 잘되어있는것임.



#### Batching

배치를 줄이기 위한 기법. 배칭을 위해선 오브젝트들이 동일한 머티리얼을 사용해야한다. 스크립트에서 머테리얼을 접근할때에도 배칭을 신경써줘야하는데 Getcomponet<Renderer>().material.color = Color.red 로 바꾸는 작업도 그냥 바꾸는게 아닌 복사본을 생성하는것이기 때문에 Renderer.sharedMaterial을 사용해야한다.

Static과 Dynamic배칭은 Edit -> Project Setting -> Player 에서 수정할 수 있다.



#### Static 배칭

정적 오브젝트를 위한 배칭기법. 인스펙터창의 Static 플래그를 켜주면 로딩타임에서 자동 배칭처리해준다. 정확히는 플래그가 체크되면 스테틱 배칭의 배상이된다. Ststic 체크 박스옆의 드롭다운 버튼을 누르면 스테틱관련 플래그들의 리스트들을 볼 수 있음. 이중 Batching Static을 체크하면 해당 오브젝트는 스테틱 배칭의 대상이된다. 일반적으로 모두 체크한다. 다이나믹배칭은 매번 버텍스 연산이 필요하지만 스테틱 배칭은 버텍스 연산을 런타임에서 수행하지 않음.

스테틱 배칭에서 생각해봐야할점은 메모리. 배칭을 사용하지 않으면 같은 메시를 사용할때 하나의 메시만 메모리에 올라가게된다. 하지만 스테틱 배칭을 하게되면 모두 합쳐져서 메모리에 올라가기때문에 메모리는 더 많이 사용하게 된다. 결론적으로는 런타임 서능이 늘어나지만 메모리문제가 발생한다면 스테틱배칭을 줄여야한다

스테틱배칭은 야외 씬에서는 썩 효율적이지 않을 수 있다. 예를들어 나무장작 더미나 수풀구자가 하나하나 별개의 모듈이 된다면 비효율적일수있음.



#### Dynamic 배칭

다이나믹 배칭은 동적으로 움직이는 오브젝트들끼리 배칭처리하는 기능. 사실 유니티가 알아서 해줌.(Edit -> ProjectSetting->Player에서 켜져있기만 하면 됨) 스테틱배칭과 달리 런타임상에서 이루어짐. Static플래그가 체크되어 있지 않는 오브젝트들의 버텍스들을 모아서 합쳐주는 과정을 거침. 이러한 버텍스들을 모아서 다이나믹 배칭에 쓰이는 버텍스 버퍼와 인덱스 버퍼에 담음. GPU는 이를 가져가서 렌더링하는 것임. 이러한 방식으로 매번 데이터 구축과 갱신이 발생하기 때문에 다이나믹 배칭은 매 프레임마다 오버헤드가 발생하긴함. 하지만 오버헤드를 갖더라도 드로우콜을 줄임으로써 전체적인 성능 향상을 가져오게됨.



위 두방법 배칭 말고도 Mesh.CombineMeshes()를 이용해서 배치를 줄일수도있다.